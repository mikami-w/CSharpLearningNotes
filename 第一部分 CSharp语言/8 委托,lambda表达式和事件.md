# 第八章 委托, lambda表达式和事件

​	委托是 .NET 对方法的寻址方式. 它相当于 C/C++ 的函数指针, 但比函数指针更加安全, 用法也略有不同. Lambda 表达式与委托直接相关, 当参数为委托类型时, 可以使用 lambda 表达式实现委托引用的方法.

​	事件一般的思路是通知代码发生了什么. GUI 编程主要处理事件. 在引发事件时, 运行库需要知道应当执行哪个方法, 这就需要把处理事件的方法作为一个参数(实参, argument)传递给委托参数(形参, parameter).

## 委托

​	委托是一种特殊类型的对象, 其包含一个或多个方法的地址. 在 .NET 中, 如果要传递方法, 就必须把方法的细节封装在委托中.

### 声明委托

​	使用类时, 一般情况下有两个步骤:

1. 定义这个类, 即告诉编译器其成员组成
2. 实例化该类的一个对象(除非只使用静态方法)

使用委托时, 也必须经过这两个步骤. 定义委托时要告诉编译器这种类型的委托表示哪种类型的方法, 然后实例化该委托的一个或多个对象来使用委托. 委托的类型安全性非常高, 定义时必须给出方法签名和返回类型.

```c#
public delegate void IntMethodInvoker(int x);
```

​	上述示例定义了一个委托`IntMethodInvoker`, 并指定该委托的每个实例都可以包含一个方法的引用, 其返回值类型为`void`, 接受一个`int`参数.

​	定义一个委托实际上定义了一个新类, 所以可以在任何可以定义类的地方定义委托. 根据可见性和作用域, 可以在委托的定义前使用任意可用的访问修饰符(`public'`, `private`, `protected`等).

### 使用委托

​	委托的构造函数总是接受一个参数, 这个参数就是委托引用的方法.

​	下面的代码展示了如何使用委托:

```c#
private delegate string GetAString();
public static void Main()
{
    int x = 40;
    GetAString stringMethod = new GetAString(x.ToString);
    Console.WriteLine($"String is {stringMethod()}");
    //output: 40
}
```

注意, `int.ToString()`是一个实例方法(非静态方法), 需要指定实例`x`和方法名来正确地初始化委托. `stringMethod`在调用时包含了调用者对象`x`的信息.
	`stringMethod()`与`stringMethod.Invoke()`完全相同. 实际上, 编译器会把前者替换为后者.

​	为减少输入量, 在实例化委托对象时可以直接使用方法名称而不使用`new`关键字, 这称为委托推断. 例如下面两个初始化语句是等价的:

```c#
GetAString stringMethod = new GetAString(x.ToString);
GetAString stringMethod = x.ToString;
```

委托推断可以在需要委托实例的任意地方使用, 也可用于事件, 因为事件是基于委托的.

​	**给定委托的实例可以引用任何类型的任何对象上的实例方法或静态方法, 只要方法的返回值类型与参数列表与委托匹配即可**. 委托只关心方法的**返回值类型**与**参数列表**, 只要方法的返回值和参数与生命的委托完全匹配即可用来初始化委托对象. 这意味着委托不关心方法由哪个对象调用, 也不关心方法是实例方法还是静态方法. 