# 第三章 对象和类型

## 类和结构

​	类是引用类型, 实例化某个类的对象需要使用new运算符, 将对象的内存分配在托管堆上. 类按**引用**传递.

​	结构不同于类, 结构不需要在堆上分配空间. **结构是值类型**, 通常存储在栈上. 结构按**值**传递. 另外,**结构不支持继承**.

* new运算符并不像C++的new一样总是在堆上分配内存
  * 若new的对象是类, 则会在堆上分配内存并调用构造函数进行初始化
  * 若new的对象是结构, 则不会分配内存, **只会调用结构的构造函数对栈上的结构进行初始化**
    * **结构对象分配内存发生在变量的声明处**, 而类变量声明只会创建引用

## 类

​	类包含成员, 成员可以是静态(static)成员或实例成员. 静态成员属于(belong to)类, 实例成员属于对象. 静态成员的值对每个对象都是相等的.
​	成员的种类见下表.

| 成员                                                         | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [字段](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/fields) | 字段是在类范围声明的变量。 字段可以是内置数值类型或其他类的实例。 例如，日历类可能具有一个包含当前日期的字段。 |
| [常量](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/constants) | 常量是在编译时设置其值并且不能更改其值的字段。               |
| [属性](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/properties) | 属性是类中可以像类中的字段一样访问的方法。 属性可以为类字段提供保护，以避免字段在对象不知道的情况下被更改。 |
| [方法](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/methods) | 方法定义类可以执行的操作。 方法可接受提供输入数据的参数，并可通过参数返回输出数据。 方法还可以不使用参数而直接返回值。 |
| [事件](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/events/) | 事件向其他对象提供有关发生的事情（如单击按钮或成功完成某个方法）的通知。 事件是使用委托定义和触发的。 |
| [运算符](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/) | 重载运算符被视为类型成员。 重载运算符时，将其定义为类型中的公共静态方法。 有关详细信息，请参阅[运算符重载](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/operator-overloading)。 |
| [索引器](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/indexers/) | 使用索引器可以用类似于数组的方式为对象建立索引。             |
| [构造函数](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/constructors) | 构造函数是首次创建对象时调用的方法。 它们通常用于初始化对象的数据。 |
| [终结器(析构函数)](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/finalizers) | C# 中很少使用终结器。 终结器是当对象即将从内存中移除时由运行时执行引擎调用的方法。 它们通常用来确保任何必须释放的资源都得到适当的处理。 |
| [嵌套类型](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/nested-types) | 嵌套类型是在其他类型中声明的类型。 嵌套类型通常用于描述仅由包含它们的类型使用的对象。 |

### 字段

​	与类相关的变量. 使用 const 关键字声明常量. 如果字段被声明为 public, 就可以在类的外部使用语法`Object.FieldName`在类的外部访问.

### 只读字段

​	带有`readonly`修饰符的字段只能在构造函数中分配值. 与常量字段相反(常量字段总是static的), 只读字段可以是实例成员, 若要使用静态只读字段, 需要显式声明为 static.

​	最好不把字段声明为 public, 而是声明为 private, 并使用属性访问字段.

### 属性

​	属性(property)的概念是: **它是一个或一对方法, 在客户端代码(调用方)看来, 它是一个字段**.
​	属性可以包含 get 和 set 访问器, 分别用于访问和设置字段的值.

```c#
class PhoneCustumer
{
    private string _firstName;
    public string FirstName
    {
        get{ return _firstName; }
        set{ _firstName = value; }
    }
    //...
}
```

​	`get`访问器不带任何参数, 且必须返回属性声明的类型. 
​	不应为`set`访问器指定任何显式参数. set访问器带一个隐式参数`value`, 其类型与属性相同.
​	上面的程序中, 字段 _firstName 作为属性 FirstName 的后备变量, 即**实际存储属性数据的变量**.

#### 具有表达式体的属性访问器

​	可以将上述属性改为以下写法:

```C#
private string _firstName;
public string FirstName
{
    get => _firstName;
    set => _firstName = value;
}
```

​	这个特性减少了编写花括号的需求, 并省略了 get 访问器的`return`语句, 但使用此特性的访问器实现只能由一条语句构成.

#### 自动实现的属性

​	如果属性的 get 和 set 访问器中没有任何逻辑, (暂时)只用于设置值, 就可以使用自动实现的属性. 表示年龄的属性可以使用以下写法:

```c#
public int Age { get; set; } = 42;
```

​	自动实现的属性可以使用属性初始化器来初始化.
​	不需要声明私有字段作为后备变量, 因为编译器会自动隐式创建它. 使用自动实现的属性就不能直接访问字段, 因为不知道编译器生成的名称. 
​	由于不能含有任意更多的语句, 上述代码无法验证属性中设置的值是否有效.

#### 属性的访问修饰符

​	C#允许为属性的 set 与 get 访问器设置不同访问修饰符, 所以属性可以有公有的 get 访问器和受保护的 set 访问器. 访问器的缺省访问级别为属性的访问级别. 两个访问器至少有一个具有属性级别的访问级别, 否则会造成编译错误.

#### 只读属性

​	省略 set 访问器, 就可以创建只读属性. 
​	可以使用相同的方式创建只写属性, 但这不是好的编程方式, 因为这样使用属性会令人感到迷惑. 如果有这样的需求, 应当使用方法代替.

#### 表达式体属性

​	只有 get 访问器的属性可以使用表达式体属性实现.

```c#
public string FirstName { get; }
public string LashName { get; }
public string FullName => $"{FirstName} {LastName}";
```

​	表达式体属性是只带有 get 访问器的属性, 但不需要编写 get 关键字, 只是属性的实现处使用 lambda 运算符`=>`构成表达式主体.

#### 不可变类型

​	如果对象没有任何可以改变的成员, 只有只读成员, 其内容只能在初始化时设置, 那么它的类型就是不可变类型.

* 这里不提常量是因为**常量总是静态的**, 不会属于某个成员

​	这种对象对于多线程是非常有用的, 因为**多个线程可以同时访问信息不会改变的一个对象**. 因为数据不会改变, 所以不需同步.

### 匿名类型

​	匿名类型是一个继承自Object且没有名称的类. `var`与`new`关键字一起使用时, 可以创建匿名类型. 该类的对象类型由编译器经初始化器推断, 类似于隐式类型化的变量.

```c#
var captain = new
{
    FirstName = "James",
    LastName = "Kirk"
};
```

​	这会生成一个包含如上两个属性的对象. 如果创建如下另一个对象:

```c#
var doctor = new
{
    FirstName = "Leonard",
    LastName = "McCoy"
}
```

那么 captain 与 doctor 的类型相同. 例如, 表达式`captain = doctor;`是合法的. 只有所有属性都匹配, 二者类型才会相同.
	如果所设置的值来自另一个对象, 则可以推断匿名类型的成员.

```c#
var person = new
{
    doctor.FirstName,
    doctor.LastName
};
```

这个新对象的属性与 doctor 相同.

​	这些新对象的类型名未知. 编译器会为这些匿名类型生成一个名称, 但只有编译器才能使用它. 我们不能也不应使用匿名类型对象上的任何类型反射, 因为这不会得到一致的结果.

### 方法

​	注意, 正式的C#术语区分函数与方法. 在C#术语中, "**函数成员**"不仅包括**方法**, 也包括类或结构的一些非数据成员, 如**索引器**, **运算符**, **构造函数**, **析构函数**, **属性**等. 这些都不是数据成员, **字段**, **常量**, **事件**才是**数据成员**.

#### 方法的声明

​	方法定义包含: 修饰符, 返回值类型, 方法名, 参数列表, 方法体.

```c#
[modifiers] return_type MethodName ([parameters])
{
    // Method body
}
```

#### 表达式体方法

​	用于实现只有一条语句的方法. 不需要编写花括号与 return 语句, 而使用运算符`=>`区分操作符左边的声明与右边的实现代码.

```c#
public bool IsSquare(Rectangle rect) => rect.Height == rect.Width;
```

这段代码等价于

```c#
public bool IsSquare(Rectangle rect)
{
    return rect.Height == rect.Width;
}
```

​	`=>`运算符右边的表达式的值是方法的返回值, 因此表达式的值必须与方法返回值类型相同.

#### 方法重载

​	C#支持方法重载, 即允许多个同名但不同签名方法的存在.

* 方法签名包括方法返回值类型, 参数列表等, 参数列表中包含参数个数与每个参数类型.
  * 但不允许只有返回值不同的多个方法同时存在, 因为这会导致编译器无法区分该调用哪一个方法

#### 显式指定名称的参数

​	考虑如下方法签名:

```c#
public void MoveAndResize(int x, int y, int width, int height)
```

​	用下面代码片段调用它, 无法从中看出使用了什么数字, 与这些数字用于哪里:

```c#
r.MoveAndResize(30, 40, 20, 40);
```

​	可以显示指定参数在签名中的名称, 明确这些数字的含义:

```c#
r.MoveAndResize(x: 30, y: 40, width: 20, height: 40);
```

​	对于这样调用的方法, 编译器会去掉变量名, 创建一个方法调用; 这在编译后的代码中没有差别.
​	还可以用这种方法更改变量的顺序,编译器会重新安排, 获得正确的顺序. 其真正优势在于可选参数的方法.

#### 可选参数

​	可以为参数提供默认值使参数变为可选参数. 可选参数必须位于方法参数列表的最后.

```c#
public void Test(int n, int opt1 = 1, int opt2 = 2, int opt3 = 3)
```

​	使用命名参数,可以传递任何位置的参数, 例如, 下面的例子仅传递最后一个可选参数:

```c#
Test(0, opt3: 9);
```

#### 个数可变的参数

​	声明数组类型的参数, 添加`params`关键字, 就可以使用任意数量的同类型参数调用该方法. 如果 params 关键字与方法签名定义的多个参数一起使用, 则 params 只能使用一次, 并且它必须是最后一个参数.

```c#
Console.WriteLine(string format, params object[] arg)
```

​	由于 object 是所有类型的父类型, 所以使用 object 数组可以把不同类型参数传递给方法.

### 构造函数

* 与C++区别: 单独包含修饰符( public 等), 且不可使用初始化列表

​	如果没有提供任何构造函数, 编译器会在后台生成一个无参数的默认构造函数, 用来把所有字段初始化为标准的默认值(数值类型为0, 引用类型为 null, bool 类型为 false). 
​	构造函数重载与其他方法规则相同. 
​	可以将构造函数限定为`private`或`protected`, 这样不相关的类就无法访问它们.

```c#
public class MyNumber
{
    private int _number;
    private MyNumber(int number)
    {
        _number = number;
    }
}
```

 	这个类没有提供任何公有的或受保护的构造函数, 这使得 MyNumber 类不能使用 new 运算符在外部代码中实例化(但可以在 MyNumber )中编写一个公有静态方法或属性以实例化此类. 在下面两种情况是有用的:

* 类仅用作静态成员或属性的容器, 因此永远不会实例化它. 这种情况下, 可以使用`static`修饰该类, 这会使得类只能包含静态成员, 不能实例化.

* 希望类仅通过调用某个静态成员函数来实例化(即所谓**对象实例化的类工厂方法**). 单例模式的实现如下:

  ```c#
  public class Singleton
  {
      private static Singleton s_instance;
      private int _state;
      private Singleton(int state)
      {
          _state = state;
      }
      public static Singleton Instance
      {
          get => s_instance ?? (s_instance = new Singleton(42));
      }
  }
  ```

  ​	`Singleton`类构造函数为私有, 所以只能在类内实例化它本身. 静态属性`Instance`返回字段`s_instance`, 如果这个字段尚未初始化(null), 则计算并返回`??`运算符右侧表达式的值, 调用构造函数创建一个实例. 若字段已经初始化, 则返回字段本身.

#### 表达式体和构造函数

​	若构造函数只有一个语句, 则也可以使用表达式体语句.

```c#
public class Singleton
{
    private static Singleton s_instance;
    private int _state;
    private Singleton(int state) => _state = state;
    public static Singleton Instance => s_instance ?? (s_instance = new Singleton(42));
}
```

#### 构造函数初始化器

​	该特性可以解决多个构造函数中有大量重复代码的问题. 

```c#
class Car
{
    private string _description;
    private uint _nWheels;
    public Car(string description, uint nWheels)
    {
        _description = description;
        _nWheels = nWheels;
    }
    public Car(string description): this(description, 4) {}
}
```

​	这里, `this`关键字仅调用参数最匹配的构造函数. 编译器会先调用`this`匹配的构造函数, 再执行当前构造函数的函数体.

* 有时也可以用参数默认值实现相同的功能

​	构造函数初始化器可以包含对同一个类另一个构造函数的调用, 也可以包含对直接基类构造函数的调用(将`this`关键字改为`base`).
​	初始化器中不能有多个调用.

#### 静态构造函数

​	静态构造函数的声明方法是

```c#
static classname()
{
    // initialization code
}
```

​	静态构造函数负责初始化类的静态字段和属性. 
​	静态构造函数只能访问类的静态成员, 不能访问实例成员.
​	.NET 运行库不确保什么时候执行静态构造函数, 也不保证多个类静态构造函数的执行顺序, 所以其中不应包含要求在某个时刻(如加载程序集时)执行的代码. .NET 运行库保证静态构造函数在第一次调用类的任何成员前执行且仅执行一次.
​	静态构造函数没有访问修饰符, 因为它从不被显式调用, 而是由.NET 运行库在加载类前调用. 出于同样原因, 静态构造函数不能有任何参数, 并且一个类最多有一个静态构造函数(不允许重载). 

## 结构

